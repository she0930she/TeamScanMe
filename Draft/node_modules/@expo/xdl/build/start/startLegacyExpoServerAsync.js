"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startExpoServerAsync = startExpoServerAsync;
exports.stopExpoServerAsync = stopExpoServerAsync;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _axios() {
  const data = _interopRequireDefault(require("axios"));

  _axios = function () {
    return data;
  };

  return data;
}

function _express() {
  const data = _interopRequireDefault(require("express"));

  _express = function () {
    return data;
  };

  return data;
}

function ConnectionStatus() {
  const data = _interopRequireWildcard(require("../ConnectionStatus"));

  ConnectionStatus = function () {
    return data;
  };

  return data;
}

function ProjectSettings() {
  const data = _interopRequireWildcard(require("../ProjectSettings"));

  ProjectSettings = function () {
    return data;
  };

  return data;
}

function Doctor() {
  const data = _interopRequireWildcard(require("../project/Doctor"));

  Doctor = function () {
    return data;
  };

  return data;
}

function ProjectUtils() {
  const data = _interopRequireWildcard(require("../project/ProjectUtils"));

  ProjectUtils = function () {
    return data;
  };

  return data;
}

function _errors() {
  const data = require("../project/errors");

  _errors = function () {
    return data;
  };

  return data;
}

function _ManifestHandler() {
  const data = require("./ManifestHandler");

  _ManifestHandler = function () {
    return data;
  };

  return data;
}

function _getFreePortAsync() {
  const data = require("./getFreePortAsync");

  _getFreePortAsync = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _isIgnorableBugReportingExtraData(body) {
  return body.length === 2 && body[0] === 'BugReporting extraData:';
}

function _isAppRegistryStartupMessage(body) {
  return body.length === 1 && (/^Running application "main" with appParams:/.test(body[0]) || /^Running "main" with \{/.test(body[0]));
}

function _handleDeviceLogs(projectRoot, deviceId, deviceName, logs) {
  for (let i = 0; i < logs.length; i++) {
    const log = logs[i];
    let body = typeof log.body === 'string' ? [log.body] : log.body;
    let {
      level
    } = log;

    if (_isIgnorableBugReportingExtraData(body)) {
      level = 'debug';
    }

    if (_isAppRegistryStartupMessage(body)) {
      body = [`Running application on ${deviceName}.`];
    }

    const args = body.map(obj => {
      if (typeof obj === 'undefined') {
        return 'undefined';
      }

      if (obj === 'null') {
        return 'null';
      }

      if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {
        return obj;
      }

      try {
        return JSON.stringify(obj);
      } catch (e) {
        return obj.toString();
      }
    });
    const logLevel = level === 'info' || level === 'warn' || level === 'error' || level === 'debug' ? level : 'info';
    ProjectUtils().getLogger(projectRoot)[logLevel]({
      tag: 'device',
      deviceId,
      deviceName,
      groupDepth: log.groupDepth,
      shouldHide: log.shouldHide,
      includesStack: log.includesStack
    }, ...args);
  }
}

async function startExpoServerAsync(projectRoot) {
  (0, _errors().assertValidProjectRoot)(projectRoot);
  await stopExpoServerAsync(projectRoot);
  const app = (0, _express().default)();
  app.use(_express().default.json({
    limit: '10mb'
  }));
  app.use(_express().default.urlencoded({
    limit: '10mb',
    extended: true
  }));

  if ((ConnectionStatus().isOffline() ? await Doctor().validateWithoutNetworkAsync(projectRoot) : await Doctor().validateWithNetworkAsync(projectRoot)) === Doctor().FATAL) {
    throw new Error(`Couldn't start project. Please fix the errors and restart the project.`);
  } // Serve the manifest.


  const manifestHandler = (0, _ManifestHandler().getManifestHandler)(projectRoot);
  app.get('/', manifestHandler);
  app.get('/manifest', manifestHandler);
  app.get('/index.exp', manifestHandler);
  app.post('/logs', async (req, res) => {
    try {
      const deviceId = req.get('Device-Id');
      const deviceName = req.get('Device-Name');

      if (deviceId && deviceName && req.body) {
        _handleDeviceLogs(projectRoot, deviceId, deviceName, req.body);
      }
    } catch (e) {
      ProjectUtils().logError(projectRoot, 'expo', `Error getting device logs: ${e} ${e.stack}`);
    }

    res.send('Success');
  });
  app.post('/shutdown', async (req, res) => {
    server.close();
    res.send('Success');
  });
  const expRc = await (0, _config().readExpRcAsync)(projectRoot);
  const expoServerPort = expRc.manifestPort ? expRc.manifestPort : await (0, _getFreePortAsync().getFreePortAsync)(19000);
  await ProjectSettings().setPackagerInfoAsync(projectRoot, {
    expoServerPort
  });
  let server = app.listen(expoServerPort, () => {
    const info = server.address();
    const host = info.address;
    const port = info.port;
    ProjectUtils().logDebug(projectRoot, 'expo', `Local server listening at http://${host}:${port}`);
  });
}

async function stopExpoServerAsync(projectRoot) {
  (0, _errors().assertValidProjectRoot)(projectRoot);
  const packagerInfo = await ProjectSettings().readPackagerInfoAsync(projectRoot);

  if (packagerInfo && packagerInfo.expoServerPort) {
    try {
      await _axios().default.request({
        method: 'post',
        url: `http://127.0.0.1:${packagerInfo.expoServerPort}/shutdown`
      });
    } catch (e) {}
  }

  await ProjectSettings().setPackagerInfoAsync(projectRoot, {
    expoServerPort: null
  });
}
//# sourceMappingURL=../__sourcemaps__/start/startLegacyExpoServerAsync.js.map
