"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const spawn_async_1 = __importDefault(require("@expo/spawn-async"));
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const PackageManager_1 = require("./PackageManager");
class CocoaPodsError extends Error {
    constructor(message, code, cause) {
        super(cause ? `${message}\n└─ Cause: ${cause.name}: ${cause.message}` : message);
        this.code = code;
        this.cause = cause;
        this.name = 'CocoaPodsError';
        this.isPackageManagerError = true;
    }
}
exports.CocoaPodsError = CocoaPodsError;
class CocoaPodsPackageManager {
    constructor({ cwd, log, silent }) {
        this.log = log || console.log;
        this.silent = !!silent;
        this.options = Object.assign({ cwd }, (silent
            ? { ignoreStdio: true }
            : {
                stdio: ['inherit', 'inherit', 'pipe'],
            }));
    }
    static getPodProjectRoot(projectRoot) {
        if (CocoaPodsPackageManager.isUsingPods(projectRoot))
            return projectRoot;
        const iosProject = path_1.default.join(projectRoot, 'ios');
        if (CocoaPodsPackageManager.isUsingPods(iosProject))
            return iosProject;
        const macOsProject = path_1.default.join(projectRoot, 'macos');
        if (CocoaPodsPackageManager.isUsingPods(macOsProject))
            return macOsProject;
        return null;
    }
    static isUsingPods(projectRoot) {
        return fs_1.existsSync(path_1.default.join(projectRoot, 'Podfile'));
    }
    static async gemInstallCLIAsync(nonInteractive = false, spawnOptions = { stdio: 'inherit' }) {
        const options = ['install', 'cocoapods', '--no-document'];
        try {
            // In case the user has run sudo before running the command we can properly install CocoaPods without prompting for an interaction.
            await spawn_async_1.default('gem', options, spawnOptions);
        }
        catch (error) {
            if (nonInteractive) {
                throw new CocoaPodsError('Failed to install CocoaPods CLI with gem (recommended)', 'COMMAND_FAILED', error);
            }
            // If the user doesn't have permission then we can prompt them to use sudo.
            await PackageManager_1.spawnSudoAsync(['gem', ...options], spawnOptions);
        }
    }
    static async brewLinkCLIAsync(spawnOptions = { stdio: 'inherit' }) {
        await spawn_async_1.default('brew', ['link', 'cocoapods'], spawnOptions);
    }
    static async brewInstallCLIAsync(spawnOptions = { stdio: 'inherit' }) {
        await spawn_async_1.default('brew', ['install', 'cocoapods'], spawnOptions);
    }
    static async installCLIAsync({ nonInteractive = false, spawnOptions = { stdio: 'inherit' }, }) {
        var _a;
        if (!spawnOptions) {
            spawnOptions = { stdio: 'inherit' };
        }
        const silent = !!spawnOptions.ignoreStdio;
        try {
            !silent && console.log(`\u203A Attempting to install CocoaPods CLI with Gem`);
            await CocoaPodsPackageManager.gemInstallCLIAsync(nonInteractive, spawnOptions);
            !silent && console.log(`\u203A Successfully installed CocoaPods CLI with Gem`);
            return true;
        }
        catch (error) {
            if (!silent) {
                console.log(chalk_1.default.yellow(`\u203A Failed to install CocoaPods CLI with Gem`));
                console.log(chalk_1.default.red((_a = error.stderr) !== null && _a !== void 0 ? _a : error.message));
                console.log(`\u203A Attempting to install CocoaPods CLI with Homebrew`);
            }
            try {
                await CocoaPodsPackageManager.brewInstallCLIAsync(spawnOptions);
                if (!(await CocoaPodsPackageManager.isCLIInstalledAsync(spawnOptions))) {
                    try {
                        await CocoaPodsPackageManager.brewLinkCLIAsync(spawnOptions);
                        // Still not available after linking? Bail out
                        if (!(await CocoaPodsPackageManager.isCLIInstalledAsync(spawnOptions))) {
                            throw new CocoaPodsError('CLI could not be installed automatically with gem or Homebrew, please install CocoaPods manually and try again', 'NO_CLI', error);
                        }
                    }
                    catch (error) {
                        throw new CocoaPodsError('Homebrew installation appeared to succeed but CocoaPods CLI not found in PATH and unable to link.', 'NO_CLI', error);
                    }
                }
                !silent && console.log(`\u203A Successfully installed CocoaPods CLI with Homebrew`);
                return true;
            }
            catch (error) {
                !silent &&
                    console.log(chalk_1.default.yellow(`\u203A Failed to install CocoaPods with Homebrew. Please install CocoaPods CLI manually and try again.`));
                throw new CocoaPodsError(`Failed to install CocoaPods with Homebrew. Please install CocoaPods CLI manually and try again.`, 'NO_CLI', error);
            }
        }
    }
    static isAvailable(projectRoot, silent) {
        if (process.platform !== 'darwin') {
            !silent && console.log(chalk_1.default.red('CocoaPods is only supported on macOS machines'));
            return false;
        }
        if (!CocoaPodsPackageManager.isUsingPods(projectRoot)) {
            !silent && console.log(chalk_1.default.yellow('CocoaPods is not supported in this project'));
            return false;
        }
        return true;
    }
    static async isCLIInstalledAsync(spawnOptions = { stdio: 'inherit' }) {
        try {
            await spawn_async_1.default('pod', ['--version'], spawnOptions);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    get name() {
        return 'CocoaPods';
    }
    async installAsync() {
        await this._installAsync();
    }
    isCLIInstalledAsync() {
        return CocoaPodsPackageManager.isCLIInstalledAsync(this.options);
    }
    installCLIAsync() {
        return CocoaPodsPackageManager.installCLIAsync({
            nonInteractive: true,
            spawnOptions: this.options,
        });
    }
    async _installAsync(shouldUpdate = true) {
        var _a;
        try {
            return await this._runAsync(['install']);
        }
        catch (error) {
            const stderr = (_a = error.stderr) !== null && _a !== void 0 ? _a : error.stdout;
            // When pods are outdated, they'll throw an error informing you to run "pod repo update"
            // Attempt to run that command and try installing again.
            if (stderr.includes('pod repo update') && shouldUpdate) {
                !this.silent &&
                    console.log(chalk_1.default.yellow(`\u203A Couldn't install Pods. ${chalk_1.default.dim(`Updating the repo and trying again.`)}`));
                await this.podRepoUpdateAsync();
                // Include a boolean to ensure pod repo update isn't invoked in the unlikely case where the pods fail to update.
                return await this._installAsync(false);
            }
            else {
                error.message = error.message || stderr;
                throw new CocoaPodsError('The command `pod install` failed', 'COMMAND_FAILED', error);
            }
        }
    }
    async addAsync(...names) {
        throw new Error('Unimplemented');
    }
    async addDevAsync(...names) {
        throw new Error('Unimplemented');
    }
    async versionAsync() {
        const { stdout } = await spawn_async_1.default('pod', ['--version'], this.options);
        return stdout.trim();
    }
    async getConfigAsync(key) {
        throw new Error('Unimplemented');
    }
    async removeLockfileAsync() {
        throw new Error('Unimplemented');
    }
    async cleanAsync() {
        throw new Error('Unimplemented');
    }
    // Private
    async podRepoUpdateAsync() {
        var _a;
        try {
            await this._runAsync(['repo', 'update']);
        }
        catch (error) {
            error.message = error.message || ((_a = error.stderr) !== null && _a !== void 0 ? _a : error.stdout);
            throw new CocoaPodsError('The command `pod repo update` failed', 'COMMAND_FAILED', error);
        }
    }
    async _runAsync(args) {
        if (!this.silent) {
            this.log(`> pod ${args.join(' ')}`);
        }
        return spawn_async_1.default('pod', [...args], this.options);
    }
}
exports.CocoaPodsPackageManager = CocoaPodsPackageManager;
//# sourceMappingURL=CocoaPodsPackageManager.js.map